# -*- coding: utf-8 -*-
"""cvTask.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lQCjmehSbeFcKuwjw2LTvy9i1Cn8RBJ8
"""

# Computer Vision Internship Program task
import tensorflow as tf
import keras
from keras.datasets import mnist
import matplotlib.pyplot
from PIL import Image
import numpy
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import Dropout
from keras.utils import np_utils
from keras.layers import Flatten
from keras.layers.convolutional import Conv2D
from keras.layers.convolutional import MaxPooling2D
from keras.preprocessing.image import ImageDataGenerator
from keras.preprocessing import image
from keras import backend as K
K.set_image_dim_ordering('th')

# 1.Download and read the data
# download the mnist dataset
# x - for image, y - for label
(X_train, y_train), (X_test, y_test) = mnist.load_data()
# read
# image_index = 641
# print(y_train[image_index])
# # plt.imshow(x_train[image_index], cmap='Greys')
# create a grid of 3x3 images
for i in range(0, 9):
	pyplot.subplot(330 + 1 + i)
	pyplot.imshow(X_train[i], cmap=pyplot.get_cmap('gray'))
# show the plot
pyplot.show()
# pyplot.imshow(x_train[666], cmap=pyplot.get_cmap('gray'))

# normalize inputs from 0-255 to 0-1
X_train = X_train / 255
X_test = X_test / 255
# one hot encode outputs
y_train = np_utils.to_categorical(y_train)
y_test = np_utils.to_categorical(y_test)
num_classes = y_test.shape[1]

# # Flipping images with Numpy
# img = x_train[888]
# img = np.array(img)
# plt.imshow(img, cmap = 'gray')
# plt.show()
# flipped_img = np.fliplr(img)
# plt.imshow(flipped_img, cmap = 'gray')
# plt.show()

# 2.Augmentation
def augmentation(X_train, X_test):
  # 2.1 Random rotation
  # reshape to be [samples][pixels][width][height]
  X_train = X_train.reshape(X_train.shape[0], 1, 28, 28)
  X_test = X_test.reshape(X_test.shape[0], 1, 28, 28)
  # convert from int to float
  X_train = X_train.astype('float32')
  X_test = X_test.astype('float32')
  # define data preparation
  datagen = ImageDataGenerator(rotation_range=90)
  # fit parameters from data
  datagen.fit(X_train)
  # configure batch size and retrieve one batch of images
  for i in range(0, 9):
    pyplot.subplot(330 + 1 + i)
    pyplot.imshow(x_train[i], cmap = pyplot.get_cmap('gray'))
  pyplot.show()
  for X_batch, y_batch in datagen.flow(X_train, y_train, batch_size=9):
    # create a grid of 3x3 images
    print("Rotated image")
    for i in range(0, 9):
      pyplot.subplot(330 + 1 + i)
      pyplot.imshow(X_batch[i].reshape(28, 28), cmap=pyplot.get_cmap('gray'))
    # show the plot
    pyplot.show()
    break
  
  # 2.2 Random shift
  # reshape to be [samples][pixels][width][height]
  X_train = X_train.reshape(X_train.shape[0], 1, 28, 28)
  X_test = X_test.reshape(X_test.shape[0], 1, 28, 28)
  # convert from int to float
  X_train = X_train.astype('float32')
  X_test = X_test.astype('float32')
  # define data preparation
  shift = 0.2
  datagen = ImageDataGenerator(width_shift_range=shift, height_shift_range=shift)
  # fit parameters from data
  datagen.fit(X_train)
  # configure batch size and retrieve one batch of images
  print("Shifted image")
  for X_batch, y_batch in datagen.flow(X_train, y_train, batch_size=9):
    # create a grid of 3x3 images
    for i in range(0, 9):
      pyplot.subplot(330 + 1 + i)
      pyplot.imshow(X_batch[i].reshape(28, 28), cmap=pyplot.get_cmap('gray'))
    # show the plot
    pyplot.show()
    break
    
  # 2.3 Random Flips
  # define data preparation
  datagen = ImageDataGenerator(horizontal_flip=True, vertical_flip=True)
  # fit parameters from data
  datagen.fit(X_train)
  # configure batch size and retrieve one batch of images
  print("Flipped image")
  for X_batch, y_batch in datagen.flow(X_train, y_train, batch_size=9):
    # create a grid of 3x3 images
    for i in range(0, 9):
      pyplot.subplot(330 + 1 + i)
      pyplot.imshow(X_batch[i].reshape(28, 28), cmap=pyplot.get_cmap('gray'))
    # show the plot
    pyplot.show()
    break
augmentation(x_train, x_test)

# Save augmented images to file
import os
# reshape to be [samples][pixels][width][height]
X_train = X_train.reshape(X_train.shape[0], 1, 28, 28)
X_test = X_test.reshape(X_test.shape[0], 1, 28, 28)
# convert from int to float
X_train = X_train.astype('float32')
X_test = X_test.astype('float32')
# define data preparation
datagen = ImageDataGenerator()
# fit parameters from data
datagen.fit(X_train)
# configure batch size and retrieve one batch of images
os.makedirs('images4')
for X_batch, y_batch in datagen.flow(X_train, y_train, batch_size=9, save_to_dir='images1', save_prefix='aug', save_format='png'):
	# create a grid of 3x3 images
	for i in range(0, 9):
		pyplot.subplot(330 + 1 + i)
		pyplot.imshow(X_batch[i].reshape(28, 28), cmap=pyplot.get_cmap('gray'))
	# show the plot
	pyplot.show()
	break

# 3.Neural network
def baseline_model():
	# create model
	model = Sequential()
	model.add(Conv2D(32, (5, 5), input_shape=(1, 28, 28), activation='relu'))
	model.add(MaxPooling2D(pool_size=(2, 2)))
	model.add(Dropout(0.2))
	model.add(Flatten())
	model.add(Dense(128, activation='relu'))
	model.add(Dense(num_classes, activation='softmax'))
	# Compile model
	model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])
	return model

# 4. Implement training
model = baseline_model()
# Fit the model
history = model.fit(X_train, y_train, validation_data=(X_test, y_test), epochs=10, batch_size=200, verbose=2)
# Final evaluation of the model
scores = model.evaluate(X_test, y_test, verbose=0)
print("CNN Error: %.2f%%" % (100-scores[1]*100))

# 5. Plot loss graph
# list all data in history
print(history.history.keys())
# summarize history for loss
pyplot.plot(history.history['loss'])
pyplot.plot(history.history['val_loss'])
pyplot.title('model loss')
pyplot.ylabel('loss')
pyplot.xlabel('epoch')
pyplot.legend(['train', 'test'], loc='upper left')
pyplot.show()

# 6. Print Accuracy
print(scores[1])

img = image.load_img('0.png',target_size=(400,400,3))
img = image.img_to_array(img)
img = img/255

# 7. make a prediction for a new image.
from keras.preprocessing.image import load_img
from keras.preprocessing.image import img_to_array
from keras.models import load_model
 
# load and prepare the image
def load_image(filename):
	# load the image
	img = load_img(filename, grayscale=True, target_size=(28, 28))
	# convert to array
	img = img_to_array(img)
	# reshape into a single sample with 1 channel
	img = img.reshape(1, 28, 28, 1)
	# prepare pixel data
	img = img.astype('float32')
	img = img / 255.0
  
	return img
 
# load an image and predict the class
def run_example():
	# load the image
	img = load_image('0.png')
# 	# load model
# 	model = load_model('final_model.h5')
	# predict the class
	digit = model.predict_classes(img)
	print(digit[0])
 
# entry point, run the example
run_example()
